apiVersion: kro.run/v1alpha1
kind: ResourceGraphDefinition
metadata:
  name: aws-generic-commons-and-bucket.kro.run
spec:
  schema:
    apiVersion: v1alpha1
    kind: AwsGenericCommonsAndBucket
    spec:
      name: string  # ⚠️ RECREATION: Changing this recreates ALL resources
      namespace: string  # ⚠️ RECREATION: Changing this recreates ALL resources
      region: string | default="us-east-1"  # ⚠️ RECREATION: Changing this recreates ALL resources
      environment: string | default="dev"  # Tag only - safe to change
      project: string | default="kro-managed"  # Tag only - safe to change
      accountId: string | default=""  # Used for naming - safe to change

      # LAYER 1: Foundation (no dependencies)
      kms:
        enabled: boolean | default=true  # Controls KMS resource creation
        description: string | default="Gen3 encryption key"  # Safe to change
        enableKeyRotation: boolean | default=true  # Safe to change after creation

      vpc:
        enabled: boolean | default=true  # Controls VPC resource creation
        # ⚠️ RECREATION: All CIDR changes recreate VPC and dependent resources
        vpcCidr: string | default="10.0.0.0/16"
        # VPC Flow Logs - can be toggled without recreation
        enableFlowLogs: boolean | default=false
        flowLogsTrafficType: string | default="ALL"
        flowLogsRetentionInDays: integer | default=1827
        subnets:
          subnet1:
            enabled: boolean | default=true  # Controls subnet1 resources
            availabilityZone: string | default=""  # e.g., "us-east-1a", defaults to ${region}a
            publicCidr: string | default="10.0.1.0/24"
            privateCidr: string | default="10.0.11.0/24"
          # Public/Private Subnet 2 in AZ-b (depends on: vpc)
          subnet2:
            enabled: boolean | default=true  # Controls subnet2 resources
            availabilityZone: string | default=""  # e.g., "us-east-1b", defaults to ${region}b
            # ⚠️ RECREATION: CIDR changes recreate subnets
            publicCidr: string | default="10.0.2.0/24"
            privateCidr: string | default="10.0.12.0/24"
          # Public/Private Subnet 3 in AZ-c (depends on: vpc)
          subnet3:
            enabled: boolean | default=false  # Controls subnet3 resources
            availabilityZone: string | default=""  # e.g., "us-east-1c", defaults to ${region}c
            # ⚠️ RECREATION: CIDR changes recreate subnets
            publicCidr: string | default="10.0.3.0/24"
            privateCidr: string | default="10.0.13.0/24"
          # Database Subnets (depends on: vpc, created when aurora/elasticache/opensearch enabled)
          database:
            subnet1AvailabilityZone: string | default=""  # e.g., "us-east-1a", defaults to ${region}a
            subnet2AvailabilityZone: string | default=""  # e.g., "us-east-1b", defaults to ${region}b
            # ⚠️ RECREATION: CIDR changes recreate DB subnets and dependent databases
            dbSubnet1Cidr: string | default="10.0.21.0/24"
            dbSubnet2Cidr: string | default="10.0.22.0/24"

      # LAYER 3: Audit & Compliance
      cloudwatch:
        enabled: boolean | default=false  # Controls CloudWatch Logs (depends on: kms)
        retentionInDays: integer | default=1827  # Safe to change after creation

      s3Logging:
        enabled: boolean | default=false  # Controls logging bucket creation
        versioning: boolean | default=false  # Safe to change after creation
        encryption: boolean | default=true  # ⚠️ RECREATION: Changing encryption recreates bucket

      cloudtrail:
        enabled: boolean | default=false  # Controls CloudTrail (depends on: s3Logging, cloudwatch, kms)
        enableLogFileValidation: boolean | default=true  # ⚠️ RECREATION: Changing this recreates trail
        includeGlobalServiceEvents: boolean | default=true  # ⚠️ RECREATION: Changing this recreates trail
        isMultiRegionTrail: boolean | default=true  # ⚠️ RECREATION: Changing this recreates trail

      # LAYER 4: Compute (depends on: vpc, subnets.subnet2/subnet3)
      eks:
        enabled: boolean | default=true  # Controls EKS cluster creation
        version: string | default="1.33"  # ⚠️ RECREATION: Version changes trigger cluster upgrade (may cause downtime)
        endpointPublicAccess: boolean | default=true  # Allow public API access
        endpointPrivateAccess: boolean | default=true  # Allow private VPC API access
        nodeGroup:
          instanceTypes: "[]string | default=[\"t3.large\"]"  # ⚠️ RECREATION: Changing this recreates node group
          desiredSize: integer | default=3  # Safe to change - triggers node group update
          minSize: integer | default=2  # Safe to change
          maxSize: integer | default=6  # Safe to change
        logging:
          enableControlPlaneLogs: boolean | default=false  # Safe to toggle
          logTypes: "[]string | default=[\"api\", \"audit\", \"authenticator\"]"  # Safe to change when logging enabled

      # LAYER 5: Data Services - Object Storage (standalone, optional kms dependency)
      dataBucket:
        enabled: boolean | default=false  # Controls data bucket creation
        versioning: boolean | default=true  # Safe to change after creation
        encryption: boolean | default=true  # ⚠️ RECREATION: Changing encryption recreates bucket
        enableAccessLogging: boolean | default=false  # Currently disabled due to schema issue

      uploadBucket:
        enabled: boolean | default=false  # Controls upload bucket creation
        versioning: boolean | default=true  # Safe to change after creation
        encryption: boolean | default=true  # ⚠️ RECREATION: Changing encryption recreates bucket
        enableAccessLogging: boolean | default=false  # Currently disabled due to schema issue

      # LAYER 5: Data Services - File Storage (depends on: vpc, kms, subnets.subnet1/subnet2/subnet3)
      efs:
        enabled: boolean | default=false  # Controls EFS creation
        performanceMode: string | default="generalPurpose"  # ⚠️ RECREATION: Changing this recreates EFS
        throughputMode: string | default="bursting"  # Safe to change after creation (can switch to provisioned)
        encrypted: boolean | default=true  # ⚠️ RECREATION: Changing encryption recreates EFS

      # LAYER 5: Data Services - Cache (depends on: vpc, subnets.database)
      elasticache:
        enabled: boolean | default=false  # Controls ElastiCache creation
        engine: string | default="redis"  # ⚠️ RECREATION: Changing engine recreates cluster
        engineVersion: string | default="7.0"  # ⚠️ RECREATION: Version changes may require downtime
        nodeType: string | default="cache.t3.micro"  # ⚠️ RECREATION: Changing node type recreates cluster
        numCacheNodes: integer | default=1  # ⚠️ RECREATION: Changing count recreates cluster
        logging:
          enableSlowLog: boolean | default=false  # Safe to toggle
          retentionInDays: integer | default=1827  # Safe to change

      # LAYER 5: Data Services - Search (depends on: vpc, subnets.database)
      opensearch:
        enabled: boolean | default=false  # Controls OpenSearch creation
        engineVersion: string | default="OpenSearch_2.11"  # ⚠️ RECREATION: Version upgrades require careful planning
        instanceType: string | default="t3.small.search"  # ⚠️ RECREATION: Changing instance type may cause downtime
        instanceCount: integer | default=1  # ⚠️ RECREATION: Scaling requires downtime for single-node clusters
        volumeSize: integer | default=10  # Safe to increase (cannot decrease)
        dedicatedMasterEnabled: boolean | default=false  # ⚠️ RECREATION: Dedicated master nodes for HA (3+ nodes recommended)
        zoneAwarenessEnabled: boolean | default=false  # ⚠️ RECREATION: Multi-AZ deployment (requires 2+ nodes)
        logging:
          enableAuditLogs: boolean | default=false  # Safe to toggle
          enableErrorLogs: boolean | default=false  # Safe to toggle
          enableIndexSlowLogs: boolean | default=false  # Safe to toggle
          enableSearchSlowLogs: boolean | default=false  # Safe to toggle
          retentionInDays: integer | default=1827  # Safe to change

      # LAYER 5: Data Services - Database (depends on: vpc, kms, subnets.database)
      aurora:
        enabled: boolean | default=true  # Controls Aurora cluster creation
        engine: string | default="aurora-postgresql"  # ⚠️ RECREATION: Changing engine recreates cluster
        engineVersion: string | default="15.4"  # ⚠️ RECREATION: Version upgrades require careful planning
        instanceClass: string | default="db.r5.large"  # ⚠️ RECREATION: Changing class may cause brief downtime
        instanceCount: integer | default=2  # Safe to scale up/down
        databaseName: string | default="gen3"  # ⚠️ RECREATION: Changing database name recreates cluster
        masterUsername: string | default="admin"  # ⚠️ RECREATION: Changing username recreates cluster
        backupRetentionPeriod: integer | default=7  # Safe to change
        monitoring:
          enableEnhancedMonitoring: boolean | default=false  # Safe to toggle
          monitoringInterval: integer | default=60  # Safe to change when monitoring enabled

    status:
      # LAYER 1: Foundation
      kmsKeyID: ${kms.?status.?keyID}
      kmsKeyARN: ${kms.?status.?keyARN}
      vpcID: ${vpcCore.?status.?vpcID}
      vpcPublicSubnet1ID: ${publicSubnet1.?status.?subnetID}
      vpcPrivateSubnet1ID: ${privateSubnet1.?status.?subnetID}
      vpcPublicSubnet2ID: ${publicSubnet2.?status.?subnetID}
      vpcPublicSubnet3ID: ${publicSubnet3.?status.?subnetID}
      vpcPrivateSubnet2ID: ${privateSubnet2.?status.?subnetID}
      vpcPrivateSubnet3ID: ${privateSubnet3.?status.?subnetID}
      vpcDbSubnet1ID: ${dbSubnet1.?status.?subnetID}
      vpcDbSubnet2ID: ${dbSubnet2.?status.?subnetID}

      # LAYER 3: Audit & Compliance
      cloudwatchLogsGroupARN: ${cloudwatchLogs.?status.?logGroupARN}
      loggingBucketName: ${loggingBucket.?status.?s3Name}
      loggingBucketArn: ${loggingBucket.?status.?s3ARN}
      cloudtrailARN: ${cloudtrail.?status.?trailARN}

      # LAYER 4: Compute - EKS Cluster
      eksClusterName: "${ has(eks.status.clusterName) ? eks.status.clusterName : '' }"
      eksClusterEndpoint: "${ has(eks.status.clusterEndpoint) ? eks.status.clusterEndpoint : '' }"
      eksClusterARN: "${ has(eks.status.clusterARN) ? eks.status.clusterARN : '' }"
      eksClusterCertificateAuthority: "${ has(eks.status.clusterCertificateAuthority) ? eks.status.clusterCertificateAuthority : '' }"
      eksClusterOIDCIssuer: "${ has(eks.status.clusterOIDCIssuer) ? eks.status.clusterOIDCIssuer : '' }"
      eksOIDCProviderARN: "${ has(eks.status.oidcProviderARN) ? eks.status.oidcProviderARN : '' }"

      # LAYER 5: Data Services
      auroraClusterEndpoint: "${ has(aurora.status.clusterEndpoint) ? aurora.status.clusterEndpoint : '' }"
      auroraReaderEndpoint: "${ has(aurora.status.readerEndpoint) ? aurora.status.readerEndpoint : '' }"
      auroraMasterPasswordSecretARN: "${ has(aurora.status.masterPasswordSecretARN) ? aurora.status.masterPasswordSecretARN : '' }"
      elasticacheEndpoint: "${ has(elasticache.status.endpoint) ? elasticache.status.endpoint : '' }"
      dataBucketName: "${ has(dataBucket.status.s3Name) ? dataBucket.status.s3Name : '' }"
      dataBucketArn: "${ has(dataBucket.status.s3ARN) ? dataBucket.status.s3ARN : '' }"
      efsFileSystemID: "${ has(efs.status.fileSystemID) ? efs.status.fileSystemID : '' }"
      uploadBucketName: "${ has(uploadBucket.status.s3Name) ? uploadBucket.status.s3Name : '' }"
      uploadBucketArn: "${ has(uploadBucket.status.s3ARN) ? uploadBucket.status.s3ARN : '' }"
      opensearchDomainARN: "${ has(opensearch.status.domainARN) ? opensearch.status.domainARN : '' }"
      opensearchDomainEndpoint: "${ has(opensearch.status.endpoint) ? opensearch.status.endpoint : '' }"

  resources:
  # LAYER 1: Foundation

  - id: kms
    includeWhen:
      - ${schema.spec.kms.enabled}
    readyWhen:
      - ${kms.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsKMS
      metadata:
        name: ${schema.spec.name}-kms
        namespace: ${schema.spec.namespace}
      spec:
        name: ${schema.spec.name}
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        accountId: ${schema.spec.accountId}
        environment: ${schema.spec.environment}
        description: ${schema.spec.kms.description}
        enableKeyRotation: ${schema.spec.kms.enableKeyRotation}

  - id: vpcCore
    includeWhen:
      - ${schema.spec.vpc.enabled}
    readyWhen:
      - ${vpcCore.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsVPC
      metadata:
        name: ${schema.spec.name}-vpc
        namespace: ${schema.spec.namespace}
      spec:
        name: ${schema.spec.name}
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        environment: ${schema.spec.environment}
        cidr:
          vpcCidr: ${schema.spec.vpc.vpcCidr}
        flowLogs:
          enabled: ${schema.spec.vpc.enableFlowLogs}
          trafficType: ${schema.spec.vpc.flowLogsTrafficType}
          retentionInDays: ${schema.spec.vpc.flowLogsRetentionInDays}

  # LAYER 2: Network - Subnets

  - id: publicSubnet1
    includeWhen:
      - ${schema.spec.vpc.subnets.subnet1.enabled}
      - ${schema.spec.vpc.enabled}
    readyWhen:
      - ${publicSubnet1.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsPublicSubnet
      metadata:
        name: ${schema.spec.name}-public-subnet-1
        namespace: ${schema.spec.namespace}
      spec:
        name: ${schema.spec.name}-1
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        environment: ${schema.spec.environment}
        availabilityZone: "${ schema.spec.vpc.subnets.subnet1.availabilityZone != \"\" ? schema.spec.vpc.subnets.subnet1.availabilityZone : schema.spec.region + \"a\" }"
        cidrBlock: ${schema.spec.vpc.subnets.subnet1.publicCidr}
        vpcID: ${vpcCore.status.vpcID}
        internetGatewayID: ${vpcCore.status.internetGatewayID}

  - id: privateSubnet1
    includeWhen:
      - ${schema.spec.vpc.subnets.subnet1.enabled}
      - ${schema.spec.vpc.enabled}
    readyWhen:
      - ${privateSubnet1.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsPrivateSubnet
      metadata:
        name: ${schema.spec.name}-private-subnet-1
        namespace: ${schema.spec.namespace}
      spec:
        name: ${schema.spec.name}-1
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        environment: ${schema.spec.environment}
        availabilityZone: "${ schema.spec.vpc.subnets.subnet1.availabilityZone != \"\" ? schema.spec.vpc.subnets.subnet1.availabilityZone : schema.spec.region + \"a\" }"
        cidrBlock: ${schema.spec.vpc.subnets.subnet1.privateCidr}
        vpcID: ${vpcCore.status.vpcID}
        publicSubnetID: ${publicSubnet1.status.subnetID}

  - id: publicSubnet2
    includeWhen:
      - ${schema.spec.vpc.subnets.subnet2.enabled}
      - ${schema.spec.vpc.enabled}
    readyWhen:
      - ${publicSubnet2.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsPublicSubnet
      metadata:
        name: ${schema.spec.name}-public-subnet-2
        namespace: ${schema.spec.namespace}
      spec:
        name: ${schema.spec.name}-2
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        environment: ${schema.spec.environment}
        availabilityZone: "${ schema.spec.vpc.subnets.subnet2.availabilityZone != \"\" ? schema.spec.vpc.subnets.subnet2.availabilityZone : schema.spec.region + \"b\" }"
        cidrBlock: ${schema.spec.vpc.subnets.subnet2.publicCidr}
        vpcID: ${vpcCore.status.vpcID}
        internetGatewayID: ${vpcCore.status.internetGatewayID}

  - id: privateSubnet2
    includeWhen:
      - ${schema.spec.vpc.subnets.subnet2.enabled}
      - ${schema.spec.vpc.enabled}
    readyWhen:
      - ${privateSubnet2.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsPrivateSubnet
      metadata:
        name: ${schema.spec.name}-private-subnet-2
        namespace: ${schema.spec.namespace}
      spec:
        name: ${schema.spec.name}-2
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        environment: ${schema.spec.environment}
        availabilityZone: "${ schema.spec.vpc.subnets.subnet2.availabilityZone != \"\" ? schema.spec.vpc.subnets.subnet2.availabilityZone : schema.spec.region + \"b\" }"
        cidrBlock: ${schema.spec.vpc.subnets.subnet2.privateCidr}
        vpcID: ${vpcCore.status.vpcID}
        publicSubnetID: ${publicSubnet2.status.subnetID}

  - id: publicSubnet3
    includeWhen:
      - ${schema.spec.vpc.subnets.subnet3.enabled}
      - ${schema.spec.vpc.enabled}
    readyWhen:
      - ${publicSubnet3.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsPublicSubnet
      metadata:
        name: ${schema.spec.name}-public-subnet-3
        namespace: ${schema.spec.namespace}
      spec:
        name: ${schema.spec.name}-3
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        environment: ${schema.spec.environment}
        availabilityZone: "${ schema.spec.vpc.subnets.subnet3.availabilityZone != \"\" ? schema.spec.vpc.subnets.subnet3.availabilityZone : schema.spec.region + \"c\" }"
        cidrBlock: ${schema.spec.vpc.subnets.subnet3.publicCidr}
        vpcID: ${vpcCore.status.vpcID}
        internetGatewayID: ${vpcCore.status.internetGatewayID}

  - id: privateSubnet3
    includeWhen:
      - ${schema.spec.vpc.subnets.subnet3.enabled}
      - ${schema.spec.vpc.enabled}
    readyWhen:
      - ${privateSubnet3.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsPrivateSubnet
      metadata:
        name: ${schema.spec.name}-private-subnet-3
        namespace: ${schema.spec.namespace}
      spec:
        name: ${schema.spec.name}-3
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        environment: ${schema.spec.environment}
        availabilityZone: "${ schema.spec.vpc.subnets.subnet3.availabilityZone != \"\" ? schema.spec.vpc.subnets.subnet3.availabilityZone : schema.spec.region + \"c\" }"
        cidrBlock: ${schema.spec.vpc.subnets.subnet3.privateCidr}
        vpcID: ${vpcCore.status.vpcID}
        publicSubnetID: ${publicSubnet3.status.subnetID}

  - id: dbSubnet1
    includeWhen:
      - ${ schema.spec.aurora.enabled || schema.spec.elasticache.enabled || schema.spec.opensearch.enabled }
      - ${schema.spec.vpc.enabled}
    readyWhen:
      - ${dbSubnet1.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsDbSubnet
      metadata:
        name: ${schema.spec.name}-db-subnet-1
        namespace: ${schema.spec.namespace}
      spec:
        name: ${schema.spec.name}-1
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        environment: ${schema.spec.environment}
        availabilityZone: "${ schema.spec.vpc.subnets.database.subnet1AvailabilityZone != \"\" ? schema.spec.vpc.subnets.database.subnet1AvailabilityZone : schema.spec.region + \"a\" }"
        cidrBlock: ${schema.spec.vpc.subnets.database.dbSubnet1Cidr}
        vpcID: ${vpcCore.status.vpcID}
        privateRouteTableID: "${ schema.spec.vpc.subnets.subnet1.enabled ? privateSubnet1.status.privateRouteTableID : vpcCore.status.privateRouteTableID }"

  - id: dbSubnet2
    includeWhen:
      - ${ schema.spec.aurora.enabled || schema.spec.elasticache.enabled || schema.spec.opensearch.enabled }
      - ${schema.spec.vpc.enabled}
    readyWhen:
      - ${dbSubnet2.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsDbSubnet
      metadata:
        name: ${schema.spec.name}-db-subnet-2
        namespace: ${schema.spec.namespace}
      spec:
        name: ${schema.spec.name}-2
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        environment: ${schema.spec.environment}
        availabilityZone: "${ schema.spec.vpc.subnets.database.subnet2AvailabilityZone != \"\" ? schema.spec.vpc.subnets.database.subnet2AvailabilityZone : schema.spec.region + \"b\" }"
        cidrBlock: ${schema.spec.vpc.subnets.database.dbSubnet2Cidr}
        vpcID: ${vpcCore.status.vpcID}
        privateRouteTableID: "${ schema.spec.vpc.subnets.subnet2.enabled ? privateSubnet2.status.privateRouteTableID : (schema.spec.vpc.subnets.subnet1.enabled ? privateSubnet1.status.privateRouteTableID : vpcCore.status.privateRouteTableID) }"

  # LAYER 3: Audit & Compliance

  - id: cloudwatchLogs
    includeWhen:
      - ${schema.spec.cloudwatch.enabled}
      - ${schema.spec.kms.enabled}
    readyWhen:
      - ${cloudwatchLogs.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsCloudWatchLogs
      metadata:
        name: ${schema.spec.name}-cloudwatch
        namespace: ${schema.spec.namespace}
      spec:
        name: ${schema.spec.name}
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        environment: ${schema.spec.environment}
        logGroupName: /aws/cloudwatch/${schema.spec.name}
        retentionInDays: ${schema.spec.cloudwatch.retentionInDays}
        kmsKeyARN: "${ schema.spec.kms.enabled ? kms.status.keyARN : \"\" }"

  - id: loggingBucket
    includeWhen:
      - ${schema.spec.s3Logging.enabled}
    readyWhen:
      - ${loggingBucket.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsS3Bucket
      metadata:
        name: ${schema.spec.name}-logging-bucket
        namespace: ${schema.spec.namespace}
      spec:
        name: "${schema.spec.name}-logging-bucket"
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        environment: ${schema.spec.environment}
        versioning: ${schema.spec.s3Logging.versioning}
        encryption: ${schema.spec.s3Logging.encryption}
        kmsKeyARN: "${ schema.spec.kms.enabled ? kms.status.keyARN : \"\" }"

  - id: cloudtrail
    includeWhen:
      - ${schema.spec.cloudtrail.enabled}
      - ${schema.spec.s3Logging.enabled}
      - ${schema.spec.cloudwatch.enabled}
      - ${schema.spec.kms.enabled}
    readyWhen:
      - ${cloudtrail.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsCloudTrail
      metadata:
        name: ${schema.spec.name}-cloudtrail
        namespace: ${schema.spec.namespace}
      spec:
        name: ${schema.spec.name}
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        environment: ${schema.spec.environment}
        accountId: ${schema.spec.accountId}
        s3BucketName: ${loggingBucket.status.s3Name}
        cloudWatchLogsLogGroupARN: ${cloudwatchLogs.status.logGroupARN}
        enableLogFileValidation: ${schema.spec.cloudtrail.enableLogFileValidation}
        includeGlobalServiceEvents: ${schema.spec.cloudtrail.includeGlobalServiceEvents}
        isMultiRegionTrail: ${schema.spec.cloudtrail.isMultiRegionTrail}
        kmsKeyARN: "${ schema.spec.kms.enabled ? kms.status.keyARN : \"\" }"

  # LAYER 4: Compute

  - id: eks
    includeWhen:
      - ${schema.spec.eks.enabled}
      - ${schema.spec.vpc.enabled}
      - ${schema.spec.vpc.subnets.subnet1.enabled}
    readyWhen:
      - ${eks.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsEKS
      metadata:
        name: ${schema.spec.name}-eks
        namespace: ${schema.spec.namespace}
      spec:
        name: ${schema.spec.name}
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        environment: ${schema.spec.environment}
        vpcID: ${vpcCore.status.vpcID}
        subnetIDs: "${ [privateSubnet1.status.subnetID] + (schema.spec.vpc.subnets.subnet2.enabled ? [privateSubnet2.status.subnetID] : []) + (schema.spec.vpc.subnets.subnet3.enabled ? [privateSubnet3.status.subnetID] : []) }"
        version: ${schema.spec.eks.version}
        endpointPublicAccess: ${schema.spec.eks.endpointPublicAccess}
        endpointPrivateAccess: ${schema.spec.eks.endpointPrivateAccess}
        nodeGroupInstanceTypes: ${schema.spec.eks.nodeGroup.instanceTypes}
        nodeGroupDesiredSize: ${schema.spec.eks.nodeGroup.desiredSize}
        nodeGroupMinSize: ${schema.spec.eks.nodeGroup.minSize}
        nodeGroupMaxSize: ${schema.spec.eks.nodeGroup.maxSize}
        logging:
          enableControlPlaneLogs: ${schema.spec.eks.logging.enableControlPlaneLogs}
          logTypes: ${schema.spec.eks.logging.logTypes}

  # LAYER 5: Data Services

  - id: dataBucket
    includeWhen:
      - ${schema.spec.dataBucket.enabled}
    readyWhen:
      - ${dataBucket.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsS3Bucket
      metadata:
        name: ${schema.spec.name}-data-bucket
        namespace: ${schema.spec.namespace}
      spec:
        name: "${schema.spec.name}-data-bucket"
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        environment: ${schema.spec.environment}
        versioning: ${schema.spec.dataBucket.versioning}
        encryption: ${schema.spec.dataBucket.encryption}
        kmsKeyARN: "${ schema.spec.kms.enabled ? kms.status.keyARN : \"\" }"

  - id: uploadBucket
    includeWhen:
      - ${schema.spec.uploadBucket.enabled}
    readyWhen:
      - ${uploadBucket.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsS3Bucket
      metadata:
        name: ${schema.spec.name}-upload-bucket
        namespace: ${schema.spec.namespace}
      spec:
        name: "${schema.spec.name}-upload-bucket"
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        environment: ${schema.spec.environment}
        versioning: ${schema.spec.uploadBucket.versioning}
        encryption: ${schema.spec.uploadBucket.encryption}
        kmsKeyARN: "${ schema.spec.kms.enabled ? kms.status.keyARN : \"\" }"

  - id: efs
    includeWhen:
      - ${schema.spec.efs.enabled}
      - ${schema.spec.kms.enabled}
      - ${schema.spec.vpc.enabled}
      - ${schema.spec.vpc.subnets.subnet1.enabled}
    readyWhen:
      - ${efs.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsEFS
      metadata:
        name: ${schema.spec.name}-efs
        namespace: ${schema.spec.namespace}
      spec:
        name: ${schema.spec.name}
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        environment: ${schema.spec.environment}
        vpcID: ${vpcCore.status.vpcID}
        subnetIDs: "${ [privateSubnet1.status.subnetID] + (schema.spec.vpc.subnets.subnet2.enabled ? [privateSubnet2.status.subnetID] : []) + (schema.spec.vpc.subnets.subnet3.enabled ? [privateSubnet3.status.subnetID] : []) }"
        privateSubnet1Cidr: ${schema.spec.vpc.subnets.subnet1.privateCidr}
        privateSubnet2Cidr: "${ schema.spec.vpc.subnets.subnet2.enabled ? schema.spec.vpc.subnets.subnet2.privateCidr : \"\" }"
        privateSubnet3Cidr: "${ schema.spec.vpc.subnets.subnet3.enabled ? schema.spec.vpc.subnets.subnet3.privateCidr : \"\" }"
        performanceMode: ${schema.spec.efs.performanceMode}
        throughputMode: ${schema.spec.efs.throughputMode}
        encrypted: ${schema.spec.efs.encrypted}
        kmsKeyARN: "${ schema.spec.kms.enabled ? kms.status.keyARN : \"\" }"

  - id: elasticache
    includeWhen:
      - ${schema.spec.elasticache.enabled}
      - ${schema.spec.vpc.enabled}
    readyWhen:
      - ${elasticache.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsElastiCache
      metadata:
        name: ${schema.spec.name}-elasticache
        namespace: ${schema.spec.namespace}
      spec:
        name: ${schema.spec.name}
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        environment: ${schema.spec.environment}
        vpcID: ${vpcCore.status.vpcID}
        subnetIDs: "${ [dbSubnet1.status.subnetID] + [dbSubnet2.status.subnetID] }"
        privateSubnet1Cidr: "${ schema.spec.vpc.subnets.subnet1.enabled ? schema.spec.vpc.subnets.subnet1.privateCidr : \"\" }"
        privateSubnet2Cidr: "${ schema.spec.vpc.subnets.subnet2.enabled ? schema.spec.vpc.subnets.subnet2.privateCidr : \"\" }"
        privateSubnet3Cidr: "${ schema.spec.vpc.subnets.subnet3.enabled ? schema.spec.vpc.subnets.subnet3.privateCidr : \"\" }"
        engine: ${schema.spec.elasticache.engine}
        engineVersion: ${schema.spec.elasticache.engineVersion}
        nodeType: ${schema.spec.elasticache.nodeType}
        numCacheNodes: ${schema.spec.elasticache.numCacheNodes}
        logging:
          enableSlowLog: ${schema.spec.elasticache.logging.enableSlowLog}
          retentionInDays: ${schema.spec.elasticache.logging.retentionInDays}

  - id: opensearch
    includeWhen:
      - ${schema.spec.opensearch.enabled}
      - ${schema.spec.vpc.enabled}
    readyWhen:
      - ${opensearch.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsOpenSearch
      metadata:
        name: ${schema.spec.name}-opensearch
        namespace: ${schema.spec.namespace}
      spec:
        name: ${schema.spec.name}
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        environment: ${schema.spec.environment}
        vpcID: ${vpcCore.status.vpcID}
        subnetIDs: "${ [dbSubnet1.status.subnetID] }"
        privateSubnet1Cidr: "${ schema.spec.vpc.subnets.subnet1.enabled ? schema.spec.vpc.subnets.subnet1.privateCidr : \"\" }"
        privateSubnet2Cidr: "${ schema.spec.vpc.subnets.subnet2.enabled ? schema.spec.vpc.subnets.subnet2.privateCidr : \"\" }"
        privateSubnet3Cidr: "${ schema.spec.vpc.subnets.subnet3.enabled ? schema.spec.vpc.subnets.subnet3.privateCidr : \"\" }"
        engineVersion: ${schema.spec.opensearch.engineVersion}
        instanceType: ${schema.spec.opensearch.instanceType}
        instanceCount: ${schema.spec.opensearch.instanceCount}
        volumeSize: ${schema.spec.opensearch.volumeSize}
        dedicatedMasterEnabled: ${schema.spec.opensearch.dedicatedMasterEnabled}
        zoneAwarenessEnabled: ${schema.spec.opensearch.zoneAwarenessEnabled}
        logging:
          enableAuditLogs: ${schema.spec.opensearch.logging.enableAuditLogs}
          enableErrorLogs: ${schema.spec.opensearch.logging.enableErrorLogs}
          enableIndexSlowLogs: ${schema.spec.opensearch.logging.enableIndexSlowLogs}
          enableSearchSlowLogs: ${schema.spec.opensearch.logging.enableSearchSlowLogs}
          retentionInDays: ${schema.spec.opensearch.logging.retentionInDays}

  - id: aurora
    includeWhen:
      - ${schema.spec.aurora.enabled}
      - ${schema.spec.kms.enabled}
      - ${schema.spec.vpc.enabled}
    readyWhen:
      - ${aurora.status.conditions.exists(c, c.type == "Ready" && c.status == "True")}
    template:
      apiVersion: kro.run/v1alpha1
      kind: AwsAurora
      metadata:
        name: ${schema.spec.name}-aurora
        namespace: ${schema.spec.namespace}
      spec:
        name: ${schema.spec.name}
        namespace: ${schema.spec.namespace}
        region: ${schema.spec.region}
        environment: ${schema.spec.environment}
        vpcID: ${vpcCore.status.vpcID}
        subnetIDs: "${ [dbSubnet1.status.subnetID] + [dbSubnet2.status.subnetID] }"
        dbSubnet1Cidr: ${schema.spec.vpc.subnets.database.dbSubnet1Cidr}
        dbSubnet2Cidr: ${schema.spec.vpc.subnets.database.dbSubnet2Cidr}
        engine: ${schema.spec.aurora.engine}
        engineVersion: ${schema.spec.aurora.engineVersion}
        instanceClass: ${schema.spec.aurora.instanceClass}
        instanceCount: ${schema.spec.aurora.instanceCount}
        databaseName: ${schema.spec.aurora.databaseName}
        masterUsername: ${schema.spec.aurora.masterUsername}
        backupRetentionPeriod: ${schema.spec.aurora.backupRetentionPeriod}
        kmsKeyARN: "${ schema.spec.kms.enabled ? kms.status.keyARN : \"\" }"
        monitoring:
          enableEnhancedMonitoring: ${schema.spec.aurora.monitoring.enableEnhancedMonitoring}
          monitoringInterval: ${schema.spec.aurora.monitoring.monitoringInterval}
