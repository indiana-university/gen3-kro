apiVersion: kro.run/v1alpha1
kind: ResourceGraphDefinition
metadata:
  name: aws-aurora.kro.run
spec:
  schema:
    apiVersion: v1alpha1
    kind: AwsAurora
    spec:
      name: string
      namespace: string
      region: string | default=""
      environment: string | default="dev"
      project: string | default="kro-managed"
      vpcID: string
      subnetIDs: "[]string"
      dbSubnet1Cidr: string | default=""
      dbSubnet2Cidr: string | default=""
      engine: string | default="aurora-postgresql"
      engineVersion: string | default="15.4"
      instanceClass: string | default="db.r5.large"
      instanceCount: integer | default=2
      databaseName: string
      masterUsername: string | default="admin"
      backupRetentionPeriod: integer | default=7
      preferredBackupWindow: string | default="03:00-04:00"
      preferredMaintenanceWindow: string | default="sun:04:00-sun:05:00"
      kmsKeyARN: string | default=""
      monitoring:
        enableEnhancedMonitoring: boolean | default=false
        monitoringInterval: integer | default=60
    status:
      clusterARN: ${cluster.status.ackResourceMetadata.arn}
      clusterID: ${cluster.spec.dbClusterIdentifier}
      clusterEndpoint: ${cluster.status.endpoint}
      readerEndpoint: ${cluster.status.readerEndpoint}
      # AWS-managed master password secret (when manageMasterUserPassword: true)
      # Secret contains: username, password, engine, host, port, dbname, dbClusterIdentifier
      # Naming pattern: rds!cluster-{dbClusterIdentifier}-{random-6-char}
      # Example: rds!cluster-my-gen3-commons-aurora-a1b2c3
      masterPasswordSecretARN: ${cluster.status.masterUserSecret.secretARN}
      monitoringRoleARN: ${monitoringRole.?status.?ackResourceMetadata.?arn}
      instance1Status: "${ has(instance1WithMonitoring.status.dbInstanceStatus) ? instance1WithMonitoring.status.dbInstanceStatus : (has(instance1WithoutMonitoring.status.dbInstanceStatus) ? instance1WithoutMonitoring.status.dbInstanceStatus : '') }"
      instance2Status: "${ has(instance2WithMonitoring.status.dbInstanceStatus) ? instance2WithMonitoring.status.dbInstanceStatus : (has(instance2WithoutMonitoring.status.dbInstanceStatus) ? instance2WithoutMonitoring.status.dbInstanceStatus : '') }"
      instance3Status: "${ has(instance3WithMonitoring.status.dbInstanceStatus) ? instance3WithMonitoring.status.dbInstanceStatus : (has(instance3WithoutMonitoring.status.dbInstanceStatus) ? instance3WithoutMonitoring.status.dbInstanceStatus : '') }"

  resources:
  - id: dbSubnetGroup
    readyWhen:
      - ${dbSubnetGroup.status.conditions.exists(c, c.type == "ACK.ResourceSynced" && c.status == "True")}
    template:
      apiVersion: rds.services.k8s.aws/v1alpha1
      kind: DBSubnetGroup
      metadata:
        namespace: ${schema.spec.namespace}
        name: ${schema.spec.name}-subnet-group
        annotations:
          services.k8s.aws/region: ${schema.spec.region}
          services.k8s.aws/adoption-policy: "adopt-or-create"
      spec:
        name: ${schema.spec.name}-subnet-group
        description: "Aurora cluster subnet group"
        subnetIDs: ${schema.spec.subnetIDs}
        tags:
        - key: Name
          value: ${schema.spec.name}-subnet-group
        - key: Environment
          value: ${schema.spec.environment}
        - key: ManagedBy
          value: Kro
        - key: Project
          value: ${schema.spec.project}
  - id: securityGroup
    readyWhen:
      - ${securityGroup.status.conditions.exists(c, c.type == "ACK.ResourceSynced" && c.status == "True")}
      - ${securityGroup.status.id != ""}
    template:
      apiVersion: ec2.services.k8s.aws/v1alpha1
      kind: SecurityGroup
      metadata:
        namespace: ${schema.spec.namespace}
        name: ${schema.spec.name}-sg
        annotations:
          services.k8s.aws/region: ${schema.spec.region}
          services.k8s.aws/adoption-policy: "adopt-or-create"
      spec:
        name: ${schema.spec.name}-sg
        description: "Aurora cluster security group"
        vpcID: ${schema.spec.vpcID}
        ingressRules:
          - fromPort: 5432
            toPort: 5432
            ipProtocol: tcp
            ipRanges:
              - cidrIP: ${schema.spec.dbSubnet1Cidr}
              - cidrIP: ${schema.spec.dbSubnet2Cidr}
        tags:
        - key: Name
          value: ${schema.spec.name}-sg
        - key: Environment
          value: ${schema.spec.environment}
        - key: ManagedBy
          value: Kro
        - key: Project
          value: ${schema.spec.project}
  - id: monitoringRole
    includeWhen:
      - ${schema.spec.monitoring.enableEnhancedMonitoring}
    readyWhen:
      - ${monitoringRole.status.conditions.exists(c, c.type == "ACK.ResourceSynced" && c.status == "True")}
      - ${monitoringRole.status.ackResourceMetadata.arn != ""}
    template:
      apiVersion: iam.services.k8s.aws/v1alpha1
      kind: Role
      metadata:
        namespace: ${schema.spec.namespace}
        name: ${schema.spec.name}-monitoring-role
        annotations:
          services.k8s.aws/adoption-policy: "adopt-or-create"
      spec:
        name: ${schema.spec.name}-monitoring-role
        description: "Aurora enhanced monitoring IAM role"
        assumeRolePolicyDocument: |
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Principal": {
                  "Service": "monitoring.rds.amazonaws.com"
                },
                "Action": "sts:AssumeRole"
              }
            ]
          }
        policies:
          - "arn:aws:iam::aws:policy/service-role/AmazonRDSEnhancedMonitoringRole"
        tags:
          - key: "Name"
            value: "${schema.spec.name}-monitoring-role"
          - key: "Environment"
            value: "${schema.spec.environment}"
          - key: "ManagedBy"
            value: "Kro"
  - id: cluster
    readyWhen:
      - ${cluster.status.conditions.exists(c, c.type == "ACK.ResourceSynced" && c.status == "True")}
      - ${cluster.status.status == "available"}
      - ${cluster.status.endpoint != ""}
      - ${cluster.status.readerEndpoint != ""}
      - ${cluster.status.masterUserSecret.secretARN != ""}
    template:
      apiVersion: rds.services.k8s.aws/v1alpha1
      kind: DBCluster
      metadata:
        namespace: ${schema.spec.namespace}
        name: ${schema.spec.name}-cluster
        annotations:
          services.k8s.aws/region: ${schema.spec.region}
          services.k8s.aws/adoption-policy: "adopt-or-create"
      spec:
        dbClusterIdentifier: ${schema.spec.name}-cluster
        engine: ${schema.spec.engine}
        engineVersion: ${schema.spec.engineVersion}
        databaseName: ${schema.spec.databaseName}
        masterUsername: ${schema.spec.masterUsername}
        manageMasterUserPassword: true
        masterUserSecretKMSKeyID: ${schema.spec.kmsKeyARN}
        dbSubnetGroupName: ${dbSubnetGroup.spec.name}
        vpcSecurityGroupIDs:
          - ${securityGroup.status.id}
        backupRetentionPeriod: ${schema.spec.backupRetentionPeriod}
        preferredBackupWindow: ${schema.spec.preferredBackupWindow}
        preferredMaintenanceWindow: ${schema.spec.preferredMaintenanceWindow}
        storageEncrypted: true
        kmsKeyID: ${schema.spec.kmsKeyARN}
        enableCloudwatchLogsExports:
          - postgresql
        tags:
        - key: Name
          value: ${schema.spec.name}-cluster
        - key: Environment
          value: ${schema.spec.environment}
        - key: ManagedBy
          value: Kro
        - key: Project
          value: ${schema.spec.project}
  # Aurora instance 1 without enhanced monitoring
  - id: instance1WithoutMonitoring
    includeWhen:
      - ${!schema.spec.monitoring.enableEnhancedMonitoring}
    readyWhen:
      - ${instance1WithoutMonitoring.status.conditions.exists(c, c.type == "ACK.ResourceSynced" && c.status == "True")}
      - ${instance1WithoutMonitoring.status.dbInstanceStatus == "available"}
    template:
      apiVersion: rds.services.k8s.aws/v1alpha1
      kind: DBInstance
      metadata:
        namespace: ${schema.spec.namespace}
        name: ${schema.spec.name}-instance-1
        annotations:
          services.k8s.aws/region: ${schema.spec.region}
          services.k8s.aws/adoption-policy: "adopt-or-create"
      spec:
        dbInstanceIdentifier: ${schema.spec.name}-instance-1
        dbInstanceClass: ${schema.spec.instanceClass}
        engine: ${schema.spec.engine}
        dbClusterIdentifier: ${cluster.spec.dbClusterIdentifier}
        publiclyAccessible: false
        monitoringInterval: 0
        tags:
        - key: Name
          value: ${schema.spec.name}-instance-1
        - key: Environment
          value: ${schema.spec.environment}
        - key: ManagedBy
          value: Kro
        - key: Project
          value: ${schema.spec.project}
  # Aurora instance 1 with enhanced monitoring
  - id: instance1WithMonitoring
    includeWhen:
      - ${schema.spec.monitoring.enableEnhancedMonitoring}
    readyWhen:
      - ${instance1WithMonitoring.status.conditions.exists(c, c.type == "ACK.ResourceSynced" && c.status == "True")}
      - ${instance1WithMonitoring.status.dbInstanceStatus == "available"}
    template:
      apiVersion: rds.services.k8s.aws/v1alpha1
      kind: DBInstance
      metadata:
        namespace: ${schema.spec.namespace}
        name: ${schema.spec.name}-instance-1
        annotations:
          services.k8s.aws/region: ${schema.spec.region}
          services.k8s.aws/adoption-policy: "adopt-or-create"
      spec:
        dbInstanceIdentifier: ${schema.spec.name}-instance-1
        dbInstanceClass: ${schema.spec.instanceClass}
        engine: ${schema.spec.engine}
        dbClusterIdentifier: ${cluster.spec.dbClusterIdentifier}
        publiclyAccessible: false
        monitoringInterval: ${schema.spec.monitoring.monitoringInterval}
        monitoringRoleARN: ${monitoringRole.status.ackResourceMetadata.arn}
        tags:
        - key: Name
          value: ${schema.spec.name}-instance-1
        - key: Environment
          value: ${schema.spec.environment}
        - key: ManagedBy
          value: Kro
        - key: Project
          value: ${schema.spec.project}
  # Aurora instance 2 without enhanced monitoring
  - id: instance2WithoutMonitoring
    includeWhen:
      - ${schema.spec.instanceCount >= 2}
      - ${!schema.spec.monitoring.enableEnhancedMonitoring}
    readyWhen:
      - ${instance2WithoutMonitoring.status.conditions.exists(c, c.type == "ACK.ResourceSynced" && c.status == "True")}
      - ${instance2WithoutMonitoring.status.dbInstanceStatus == "available"}
    template:
      apiVersion: rds.services.k8s.aws/v1alpha1
      kind: DBInstance
      metadata:
        namespace: ${schema.spec.namespace}
        name: ${schema.spec.name}-instance-2
        annotations:
          services.k8s.aws/region: ${schema.spec.region}
          services.k8s.aws/adoption-policy: "adopt-or-create"
      spec:
        dbInstanceIdentifier: ${schema.spec.name}-instance-2
        dbInstanceClass: ${schema.spec.instanceClass}
        engine: ${schema.spec.engine}
        dbClusterIdentifier: ${cluster.spec.dbClusterIdentifier}
        publiclyAccessible: false
        monitoringInterval: 0
        tags:
        - key: Name
          value: ${schema.spec.name}-instance-2
        - key: Environment
          value: ${schema.spec.environment}
        - key: ManagedBy
          value: Kro
        - key: Project
          value: ${schema.spec.project}
  # Aurora instance 2 with enhanced monitoring
  - id: instance2WithMonitoring
    includeWhen:
      - ${schema.spec.instanceCount >= 2}
      - ${schema.spec.monitoring.enableEnhancedMonitoring}
    readyWhen:
      - ${instance2WithMonitoring.status.conditions.exists(c, c.type == "ACK.ResourceSynced" && c.status == "True")}
      - ${instance2WithMonitoring.status.dbInstanceStatus == "available"}
    template:
      apiVersion: rds.services.k8s.aws/v1alpha1
      kind: DBInstance
      metadata:
        namespace: ${schema.spec.namespace}
        name: ${schema.spec.name}-instance-2
        annotations:
          services.k8s.aws/region: ${schema.spec.region}
          services.k8s.aws/adoption-policy: "adopt-or-create"
      spec:
        dbInstanceIdentifier: ${schema.spec.name}-instance-2
        dbInstanceClass: ${schema.spec.instanceClass}
        engine: ${schema.spec.engine}
        dbClusterIdentifier: ${cluster.spec.dbClusterIdentifier}
        publiclyAccessible: false
        monitoringInterval: ${schema.spec.monitoring.monitoringInterval}
        monitoringRoleARN: ${monitoringRole.status.ackResourceMetadata.arn}
        tags:
        - key: Name
          value: ${schema.spec.name}-instance-2
        - key: Environment
          value: ${schema.spec.environment}
        - key: ManagedBy
          value: Kro
        - key: Project
          value: ${schema.spec.project}
  - id: instance3WithMonitoring
    includeWhen:
      - ${schema.spec.instanceCount >= 3}
      - ${schema.spec.monitoring.enableEnhancedMonitoring}
    readyWhen:
      - ${instance3WithMonitoring.status.conditions.exists(c, c.type == "ACK.ResourceSynced" && c.status == "True")}
      - ${instance3WithMonitoring.status.dbInstanceStatus == "available"}
    template:
      apiVersion: rds.services.k8s.aws/v1alpha1
      kind: DBInstance
      metadata:
        namespace: ${schema.spec.namespace}
        name: ${schema.spec.name}-instance-3
        annotations:
          services.k8s.aws/region: ${schema.spec.region}
          services.k8s.aws/adoption-policy: "adopt-or-create"
      spec:
        dbInstanceIdentifier: ${schema.spec.name}-instance-3
        dbInstanceClass: ${schema.spec.instanceClass}
        engine: ${schema.spec.engine}
        dbClusterIdentifier: ${cluster.spec.dbClusterIdentifier}
        publiclyAccessible: false
        monitoringInterval: ${schema.spec.monitoring.monitoringInterval}
        monitoringRoleARN: ${monitoringRole.status.ackResourceMetadata.arn}
        tags:
        - key: Name
          value: ${schema.spec.name}-instance-3
        - key: Environment
          value: ${schema.spec.environment}
        - key: ManagedBy
          value: Kro
        - key: Project
          value: ${schema.spec.project}
