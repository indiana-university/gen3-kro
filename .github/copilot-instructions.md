# GitHub Copilot Instructions for gen3-kro

## Project Overview
Multi-account EKS cluster management platform using **Terragrunt** (DRY infrastructure), **Argo CD** (GitOps), **KRO** (Kubernetes Resource Operator), and **AWS ACK** (AWS Controllers for Kubernetes). Hub-and-spoke architecture for cross-account resource provisioning.

## Architecture: Hub-and-Spoke Model

**Hub Cluster**: Central control plane running:
- Argo CD for GitOps orchestration
- ACK controllers (IAM, EC2, EKS, etc.) for AWS resource management
- KRO for declarative resource graph definitions (RGDs)

**Spoke Accounts**: External AWS accounts accessed via cross-account IAM roles

**Infrastructure Stack**:
- **Terragrunt**: DRY infrastructure-as-code with dynamic provider generation
- **Terraform**: EKS clusters (Kind support removed)
- **Single Configuration**: `terraform/config.yaml` (YAML format)
- **No Generated Files**: Providers/versions generated by Terragrunt (excluded from git)

## Critical File Patterns

### Terragrunt Wrapper: `bootstrap/terragrunt-wrapper.sh`
Main CLI for all infrastructure operations, replacing legacy `init-tf.sh`.

**Usage**:
```bash
./bootstrap/terragrunt-wrapper.sh <environment> <command> [options]
```

**Examples**:
```bash
# Validate configuration
./bootstrap/terragrunt-wrapper.sh staging validate

# Plan changes
./bootstrap/terragrunt-wrapper.sh prod plan

# Apply (requires confirmation for prod)
./bootstrap/terragrunt-wrapper.sh staging apply

# Destroy (requires YES confirmation)
./bootstrap/terragrunt-wrapper.sh prod destroy

# Show outputs
./bootstrap/terragrunt-wrapper.sh prod output

# Generate dependency graph
./bootstrap/terragrunt-wrapper.sh prod graph
```

**Key Features**:
- Auto-confirmation for destructive operations
- Comprehensive validation (YAML, AWS credentials, required tools)
- Logging to `outputs/logs/terragrunt-*.log`
- Support for `--yes`, `--verbose`, `--debug` flags

### Configuration Files

**`terraform/config.yaml`**: Single centralized configuration (YAML)
```yaml
hub:
  aws_profile: "boadeyem_tf"      # AWS CLI profile for hub
  aws_region: "us-east-1"
  cluster_name: "gen3-kro-hub"
  kubernetes_version: "1.31"

ack:
  namespace: "ack-system"
  controllers:                     # ACK services to deploy
    - rds
    - eks
    - s3
    - ec2

spokes:
  - alias: "spoke1"
    region: "us-east-1"
    profile: "boadeyem_tf"         # Same account for demo
    account_id: ""                 # Auto-detected if empty
    tags:
      Environment: "prod"
      Team: "platform"

gitops:
  org_name: "indiana-university"
  repo_name: "gen3-kro"
  addons:
    path: "addons/bootstrap"
    revision: "main"
```

**Key Sections**:
- `hub`: Hub cluster configuration
- `ack`: ACK controllers and namespace
- `spokes`: Array of spoke accounts (YAML format)
- `kro`: KRO operator configuration
- `gitops`: Repository paths and revisions
- `paths`: Output directories and state bucket
- `deployment`: Common deployment settings
- `addons`: Feature flags for addons

### Terragrunt Structure

```
terraform/
├── config.yaml                   # ✅ Single source of truth
├── terragrunt.hcl               # ✅ Root configuration
├── .terraform-version           # ✅ Version pinning (1.5.7)
├── live/                        # ✅ Environment configs
│   ├── prod/
│   │   └── terragrunt.hcl      # Production settings
│   └── staging/
│       └── terragrunt.hcl      # Staging settings
├── env/                         # ❌ Empty (cleaned up)
└── modules/
    ├── root/                    # Orchestrator module
    │   ├── main.tf             # Always creates EKS (no Kind)
    │   ├── locals.tf
    │   └── variables.tf
    ├── eks-hub/                # Production EKS + VPC
    ├── iam-access/             # Cross-account IAM
    └── argocd-bootstrap/       # ArgoCD installation
```

**Critical**:
- `providers.tf`, `versions.tf`, `backend.tf` are **generated by Terragrunt** - never commit
- `terraform/env/dev/` and `terraform/env/prod/` **deleted** - use `live/` instead
- `kind-hub/` module **removed** - EKS-only infrastructure
- All obsolete files backed up to `outputs/backups/obsolete-files-*/`

### Backend Configuration

**S3 Backend** (NO DynamoDB locking):
```hcl
bucket  = "gen3-kro-envs-4852"
region  = "us-east-1"
encrypt = true

# State isolation by environment:
# - prod:    s3://.../prod/terraform.tfstate
# - staging: s3://.../staging/terraform.tfstate
```

**Important**: DynamoDB locking **intentionally disabled** to prevent lock corruption from killed processes.

### IAM Cross-Account Pattern

Two architectures based on `enable_cross_account_iam` variable:

**External Spoke** (cross-account, prod environment):
```hcl
enable_external_spoke = var.enable_cross_account_iam && 
                        var.hub_account_id != local.spoke_account_id
```
- Hub: IAM role → assumes spoke role
- Spoke: IAM role trusts hub account
- Hub: EKS Pod Identity links service account → hub role

**Internal Spoke** (same account or disabled):
```hcl
enable_internal_spoke = !var.enable_cross_account_iam || 
                        var.hub_account_id == local.spoke_account_id
```
- Direct IAM roles with EKS Pod Identity in hub account

See: `terraform/modules/iam-access/main.tf`

### Argo CD ApplicationSets

Located in `fleet/bootstrap/`:
- `addons.yaml`: Core infrastructure (sync-wave: `-1`)
- `clusters.yaml`: KRO RGDs (sync-wave: `0`)
- `web-store-*-appset.yaml`: Workloads (sync-wave: `3`)

**Go Template Variables**:
- `{{.metadata.labels.environment}}`: dev/staging/prod
- `{{.metadata.labels.tenant}}`: tenant1, etc.
- `{{.metadata.annotations.fleet_repo_url}}`: Git repo URL

**Value File Layering** (last wins):
```yaml
valueFiles:
  - '$values/kro-values/default/...'           # Base
  - '$values/kro-values/tenants/{{tenant}}/...'  # Tenant overrides
```

## Developer Workflows

### Bootstrap Hub Cluster (Terragrunt)
```bash
# 1. Configure (single YAML file)
vim terraform/config.yaml

# 2. Validate
./bootstrap/terragrunt-wrapper.sh staging validate

# 3. Plan
./bootstrap/terragrunt-wrapper.sh staging plan

# 4. Apply (test in staging first!)
./bootstrap/terragrunt-wrapper.sh staging apply

# 5. Promote to production
./bootstrap/terragrunt-wrapper.sh prod plan
./bootstrap/terragrunt-wrapper.sh prod apply  # Requires YES confirmation
```

### Add New Spoke Account
```bash
# 1. Edit config.yaml
vim terraform/config.yaml

# Add to spokes array:
# - alias: "spoke2"
#   region: "us-west-2"
#   profile: "spoke2-profile"
#   account_id: "210987654321"

# 2. Plan and apply
./bootstrap/terragrunt-wrapper.sh prod plan
./bootstrap/terragrunt-wrapper.sh prod apply
```

### KRO Demo (Local Development)
```bash
cd kro
./kro-demo.sh  # Iterative create/modify/cleanup loop
```

Logs: `kro/logs/kro-jimi.log`

### Terragrunt Guardrails
- **Production confirm**: Requires typing "YES" for apply/destroy
- **Auto-approve**: Use `--yes` flag to skip prompts (use with caution!)
- **Plan artifacts**: Saved as `tfplan` in environment directory
- **Logs**: `outputs/logs/terragrunt-<timestamp>.log`
- **Verbose mode**: `--verbose` flag for detailed output
- **Debug mode**: `--debug` flag sets `TF_LOG=DEBUG`

## Shell Scripting Conventions

**Standard Preamble**:
```bash
#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'
```

**Logging Functions** (from `bootstrap/lib-logging.sh`):
```bash
log_info "message"      # [INFO] - General information
log_success "message"   # [SUCCESS] - Operation succeeded
log_warn "message"      # [WARN] - Warning, non-fatal
log_error "message"     # [ERROR] - Error, may exit
log_notice "message"    # [NOTE] - Important notice
log_debug "message"     # [DEBUG] - Debug info (if VERBOSE=1)
```

**Path Resolution**:
```bash
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd -P)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd -P)"
```

**Shellcheck**: Disable annotations used (e.g., `#shellcheck disable=SC2034`)

## ACK Controller Integration

ACK services configured in `terraform/config.yaml`:
```yaml
ack:
  namespace: "ack-system"
  controllers:
    - iam
    - ec2
    - eks
    - s3
    - rds
```

**Dynamic Policy Fetching**:
```hcl
data "http" "policy_arn" {
  url = "https://raw.githubusercontent.com/aws-controllers-k8s/${service}-controller/main/config/iam/recommended-policy-arn"
}
```

**Namespace**: All ACK controllers run in `ack-system`

## Testing Requirements

### ⚠️ CRITICAL - Pre-Deployment Validation

**Every environment MUST pass these tests before accepting changes**:

#### 1. Configuration Validation
```bash
# Validate YAML syntax
yq eval '.' terraform/config.yaml

# Validate with Terragrunt wrapper
./bootstrap/terragrunt-wrapper.sh <env> validate
```

#### 2. Terraform Validation (Per Environment)
```bash
# Staging validation
./bootstrap/terragrunt-wrapper.sh staging validate

# Production validation  
./bootstrap/terragrunt-wrapper.sh prod validate
```

**Expected Output**:
```
✓ Configuration validation passed
✓ Terragrunt initialized
✓ Configuration is valid
```

#### 3. Terraform Plan (Per Environment)
```bash
# Generate and review staging plan
./bootstrap/terragrunt-wrapper.sh staging plan
# Review: tfplan file created
# Review: No unexpected resource changes

# Generate and review production plan
./bootstrap/terragrunt-wrapper.sh prod plan
# Review: tfplan file created
# Review: No unexpected resource changes
```

**Plan Review Checklist**:
- ✅ No unintended resource deletions
- ✅ Provider configurations correct (AWS profiles, regions)
- ✅ Backend state path correct for environment
- ✅ Module sources resolve correctly
- ✅ Variable values match expectations
- ✅ Tags include correct environment/deployment_stage

#### 4. Direct Terragrunt Tests
```bash
# Navigate to environment
cd terraform/live/staging

# Initialize
terragrunt init

# Validate
terragrunt validate

# Plan
terragrunt plan -out=tfplan

# Show plan
terragrunt show tfplan

# Check for syntax errors
echo $?  # Should return 0
```

#### 5. AWS Credential Validation
```bash
# Verify hub profile
aws sts get-caller-identity --profile boadeyem_tf

# Verify spoke profiles (if different)
aws sts get-caller-identity --profile <spoke_profile>

# Check S3 bucket access
aws s3 ls s3://gen3-kro-envs-4852/ --profile boadeyem_tf
```

### Test Matrix (Required Before Merge)

| Test | Staging | Production | Status |
|------|---------|------------|--------|
| YAML syntax validation | ✅ Required | ✅ Required | Must pass |
| Config validation | ✅ Required | ✅ Required | Must pass |
| Terraform validate | ✅ Required | ✅ Required | Must pass |
| Terraform plan | ✅ Required | ✅ Required | Must pass |
| AWS credentials | ✅ Required | ✅ Required | Must pass |
| Provider generation | ✅ Required | ✅ Required | Must pass |
| Backend connectivity | ✅ Required | ✅ Required | Must pass |

### Failure Scenarios (Do NOT Proceed)

❌ **Stop if any of these occur**:
- Terraform validation fails
- Plan shows unexpected deletions
- AWS credentials invalid
- S3 backend inaccessible
- Provider version conflicts
- Syntax errors in generated files
- YAML parsing errors

## Common Pitfalls

1. **Configuration Format**: Must be valid YAML in `terraform/config.yaml`
2. **AWS Profiles**: Ensure profiles exist in `~/.aws/credentials` before running
3. **Generated Files**: Never commit `providers.tf`, `versions.tf`, or `backend.tf` in `live/` directories
4. **Environment Variable**: Now uses `deployment_stage` (not `environment`) for tagging
5. **Plan Artifacts**: Review plan before apply, especially for production
6. **Spoke Format**: Use YAML array, not old space-separated format
7. **Module References**: Kind module removed, only EKS supported
8. **State Paths**: Different for each environment (`prod/`, `staging/`)

## Key Dependencies

**Required Tools**:
- Terragrunt (latest stable)
- Terraform >= 1.5.0, < 2.0.0
- kubectl (latest stable)
- helm (latest stable)
- jq (for JSON processing)
- yq (for YAML processing, or python as fallback)
- AWS CLI with configured profiles

**Verify Installation**:
```bash
terragrunt --version
terraform version
kubectl version --client
helm version
jq --version
yq --version
aws --version
```

## Validation Commands

**Validate Everything**:
```bash
# Validate configuration file
yq eval '.' terraform/config.yaml

# Validate staging
./bootstrap/terragrunt-wrapper.sh staging validate
./bootstrap/terragrunt-wrapper.sh staging plan

# Validate production
./bootstrap/terragrunt-wrapper.sh prod validate
./bootstrap/terragrunt-wrapper.sh prod plan

# Check Argo Apps (after deployment)
kubectl get applications,applicationsets -n argocd

# View KRO RGDs (after deployment)
kubectl get resourcegraphdefinitions -n kro

# Verify state files
aws s3 ls s3://gen3-kro-envs-4852/ --profile boadeyem_tf --recursive
```

## Gitignore Notes

Excluded from version control:
- `**/logs/`, `**/*.log`
- `**/secrets/`, `**/*.pem`
- Terraform state/plans: `**/*.tfstate`, `**/*.tfplan`
- Generated outputs: `**/outputs/`
- **Terragrunt generated**: `**/providers.tf`, `**/versions.tf`, `**/backend.tf`, `**/kube_providers.tf` (in `live/` directories)
- Terragrunt cache: `**/.terragrunt-cache/`
- Specific dirs: `addons/`, `apps/`, `fleet/`, `charts/`, `platform/`, `kro/`

## ⚠️ CRITICAL - Process Management

**Terraform/Terragrunt Process Safety**:
- **NEVER kill Terraform/Terragrunt processes** (no Ctrl+C, no `kill` commands)
- Always wait for commands to complete or timeout naturally
- Check every 60 seconds for progress
- Killing processes can cause state corruption
- Do not use timeout command with Terraform or Terragrunt commands

- If a command hangs:
  1. Check every 60 seconds for progress
  2. Investigate root cause (AWS API limits, network issues, etc.)
  3. Wait for natural timeout or completion
  4. Manual intervention by user if absolutely necessary

**Why This Matters**:
- Terraform writes state incrementally during operations
- Interrupted writes → corrupted state
- No DynamoDB locking → no automatic recovery
- Recovery requires manual state manipulation

**Termination**:
- do not include exit or timeout commands in scripts or wrappers or chat responses, just wait and check every 60 seconds

## File Structure Summary

### Active Files
```
bootstrap/
├── terragrunt-wrapper.sh              # ✅ Main CLI
├── lib-logging.sh                     # ✅ Logging library
└── implement-terragrunt-migration.sh  # ✅ Reference (migration complete)

terraform/
├── config.yaml                        # ✅ Single config
├── terragrunt.hcl                     # ✅ Root Terragrunt
├── .terraform-version                 # ✅ Version pin
├── live/
│   ├── prod/terragrunt.hcl           # ✅ Production
│   └── staging/terragrunt.hcl        # ✅ Staging
└── modules/
    ├── root/                          # ✅ Orchestrator
    ├── eks-hub/                       # ✅ EKS cluster
    ├── iam-access/                    # ✅ Cross-account IAM
    └── argocd-bootstrap/              # ✅ ArgoCD
```

### Obsolete Files (Deleted, Backed Up)
```
❌ bootstrap/init-tf.sh                # Replaced by terragrunt-wrapper.sh
❌ bootstrap/controller-list.env       # Moved to config.yaml
❌ bootstrap/spokes-list.env           # Moved to config.yaml
❌ bootstrap/providers.tf.tpl          # Generated by Terragrunt
❌ terraform/env/dev/                  # No longer used
❌ terraform/env/prod/                 # Replaced by live/
❌ terraform/modules/kind-hub/         # Kind support removed
❌ kro/core.env                        # Moved to config.yaml
❌ kro/mods.env                        # Moved to config.yaml
```

**Backups**: All deleted files saved to `outputs/backups/obsolete-files-*/`

## Quick Reference

### Daily Operations
```bash
# Edit configuration
vim terraform/config.yaml

# Test in staging
./bootstrap/terragrunt-wrapper.sh staging validate
./bootstrap/terragrunt-wrapper.sh staging plan
./bootstrap/terragrunt-wrapper.sh staging apply

# Promote to production
./bootstrap/terragrunt-wrapper.sh prod validate
./bootstrap/terragrunt-wrapper.sh prod plan
./bootstrap/terragrunt-wrapper.sh prod apply
```

### Troubleshooting
```bash
# Enable verbose logging
./bootstrap/terragrunt-wrapper.sh staging plan --verbose

# Enable debug
./bootstrap/terragrunt-wrapper.sh staging plan --debug

# View logs
tail -f outputs/logs/terragrunt-*.log

# Check generated files
cd terraform/live/staging
ls -la *.tf

# Clean cache and regenerate
find . -name ".terragrunt-cache" -exec rm -rf {} +
terragrunt init
```

### Multi-Environment Operations
```bash
# Run command across all environments
cd terraform/live
terragrunt run-all plan
terragrunt run-all validate

# Note: Use with caution, test staging first!
```

## 📝 Migration Notes

**Completed**: October 5, 2025
- ✅ Migrated from vanilla Terraform to Terragrunt
- ✅ Consolidated 4+ env files to single `config.yaml`
- ✅ Removed Kind cluster support (EKS-only)
- ✅ Simplified CLI from 11+ args to 2 args
- ✅ Removed DynamoDB state locking
- ✅ Dynamic provider generation via Terragrunt
- ✅ All obsolete files cleaned up and backed up

**Active Configuration**:
- Hub Account: `boadeyem_tf`
- Spoke Account: `boadeyem_tf` (same account for demo)
- Environments: `staging`, `prod`
- State Bucket: `gen3-kro-envs-4852`
- No DynamoDB Locking: Intentional design decision
